#include <stdio.h> /* for printf */
#include <stdlib.h> /* for malloc */

typedef struct node {
  int data;
  struct node *next; /* pointer to next element in list */
} LLIST;

/* 先頭に挿入 */
LLIST *list_add_head(LLIST **p, int i)
{
  LLIST *n = (LLIST *) malloc(sizeof(LLIST));
  if (n == NULL) return NULL;

  n->next = *p;
  *p = n;
  n->data = i;

  //return *p; /* ←こっちでも同じだよ */
  return n;
}

/* 末尾にエンキューする */
LLIST *enqueue(LLIST **p, int i)
{
  LLIST *ptr = *p;
  printf("ENQ(%d)¥n",i);
  if(*p == NULL) //初回時のみ特別
    return list_add_head(p, i);

  while(ptr->next != NULL)//ptrが末尾ノードを指す状態にする
    ptr = ptr->next;

  LLIST *n = (LLIST *) malloc(sizeof(LLIST));
  if (n == NULL)
    return NULL;

  n->next = ptr->next;
  ptr->next = n;
  n->data = i;
  //ptr->next->data = i;

  return n;
}

/* 先頭からデキュー */
void dequeue(LLIST **p)
{
  if (*p != NULL)
    {
      printf("DEQ(%d)¥n",(*p)->data);
      LLIST *n = *p;
      //*p = (*p)->next; /* (*p)、n、どちらでも同じだよ */
      *p = n->next;
      free(n);
    }
  else
    {
      printf("cannot remove, because queue is empty¥n");
    }
}


/* 先頭から順に表示 */
void look(LLIST *n)
{
  printf("QUEUE : ");
  if (n == NULL)
    {
      printf("queue is empty¥n");
      return ;
    }
  while (n != NULL)
    {
      printf("[%2d]", n->data);
      n = n->next;
    }
  printf("¥n¥n");
}

int main(void)
{
  LLIST *n = NULL;

  look(n);
  enqueue(&n, 0);
  look(n);
  enqueue(&n, 1);
  look(n);
  enqueue(&n, 2);
  look(n);
  enqueue(&n, 3);
  look(n);
  enqueue(&n, 4);
  look(n);

  dequeue(&n);
  look(n);
  dequeue(&n);
  look(n);
  dequeue(&n);
  look(n);
  dequeue(&n);
  look(n);
  dequeue(&n);
  look(n);

  return 0;
}

/*
  実行結果

  QUEUE : queue is empty¥nENQ(0)
  QUEUE : [ 0]

  ENQ(1)
  QUEUE : [ 0][ 1]

  ENQ(2)
  QUEUE : [ 0][ 1][ 2]

  ENQ(3)
  QUEUE : [ 0][ 1][ 2][ 3]

  ENQ(4)
  QUEUE : [ 0][ 1][ 2][ 3][ 4]

  DEQ(0)
  QUEUE : [ 1][ 2][ 3][ 4]

  DEQ(1)
  QUEUE : [ 2][ 3][ 4]

  DEQ(2)
  QUEUE : [ 3][ 4]

  DEQ(3)
  QUEUE : [ 4]

  DEQ(4)
  QUEUE : queue is empty¥nENQ
*/
